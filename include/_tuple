// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_TUPLE
#define _LIBCPP_TUPLE

#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {
#define _LIBCPP_END_NAMESPACE_STD   }

#define __has_keyword(__x) !(__is_identifier(__x))

#if __has_attribute(__nodebug__) && (defined(_LIBCPP_CLANG_VER) && _LIBCPP_CLANG_VER >= 900)
#   define _LIBCPP_NODEBUG_TYPE __attribute__((nodebug))
#else
#   define _LIBCPP_NODEBUG_TYPE
#endif

#if __has_attribute(__nodebug__) && (defined(_LIBCPP_CLANG_VER) && _LIBCPP_CLANG_VER >= 900)
#   define _LIBCPP_NODEBUG_TYPE __attribute__((nodebug))
#else
#   define _LIBCPP_NODEBUG_TYPE
#endif
_LIBCPP_BEGIN_NAMESPACE_STD


    template<size_t...>
    struct __tuple_indices {
    };

    template<class _IdxType, _IdxType... _Values>
    struct __integer_sequence {
        template<template<class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
        using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

        template<size_t _Sp>
        using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
    };

#if __has_builtin(__make_integer_seq)
    template <size_t _Ep, size_t _Sp>
    using __make_indices_imp =
        typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
        __to_tuple_indices<_Sp>;
#else
    template<size_t _Ep, size_t _Sp>
    using __make_indices_imp =
    typename __detail::__make<_Ep - _Sp>::type::template __to_tuple_indices<_Sp>;

#endif


    template<size_t _Ep, size_t _Sp = 0>
    struct __make_tuple_indices {
        static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
        typedef __make_indices_imp<_Ep, _Sp> type;
    };

// remove_reference

#if __has_keyword(__remove_reference)

    template<class _Tp>
    struct _LIBCPP_TEMPLATE_VIS remove_reference { typedef __remove_reference(_Tp) type; };

#else // __has_keyword(__remove_reference)

#if _LIBCPP_STD_VER > 11
    template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
#endif

#endif // __has_keyword(__remove_reference)

    template<class _Tp>
    struct __uncvref {
        typedef _LIBCPP_NODEBUG_TYPE typename remove_cv<typename remove_reference<_Tp>::type>::type type;
    };
_LIBCPP_END_NAMESPACE_STD

#endif // _LIBCPP_TUPLE
